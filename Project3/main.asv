clear; clc; close all;

% 
% Given values 
% 

tspan = [0, 300];
teval = (1:3000)/10;
x0 = [2; 0];
p = [0.05; 4; 0.2; -0.5; 10; pi/2];
sigma = 0.1;



% Initial conditions
phi0 = eye(2);
psi0 = zeros(2, 6);
y0 = [x0(:); phi0(:); psi0(:)];

% Integrating ODE 
% Creating a "true" simulation of motion
% Then creating integrating to return points at measurements
opts = odeset('RelTol', 1E-8, 'AbsTol',1E-9);
func = @(t, y) xdot(t, y, p);

% Measured States
[t, measured_states] = ode45(func, teval, x0, opts);

% "True Motion Solution"
[t, true_state] = ode45(func, tspan, x0, opts);

% Adding Random Noise 
% ytilde = x(t) + v_i
% Setting seed for repeatability
rng(2025);
ytilde = measured_states(:, 1) + sigma * randn(length(teval));

% Plotting Generated Solution
subplot(2, 1, 1)
plot(t, true_state(:, 1))

subplot(2, 1, 2)
plot(t, true_state(:, 2))

figure
plot(true_state(:, 1), true_state(:, 2))

figure
hold on
plot(t, t)


%% Function Definitions
function f = xdot(t, x, p)
    f = [x(2);
        -p(1)*x(2) - p(2)*x(1) - p(3)*x(1)^2 - p(4)*sin(p(5)*t+p(6))];
end

function f = dynamics(t, y, p)
    
    % Extract x, Phi, Psi
    x = y(1:2);
    phi = reshape(y(3:6), 2, 2);
    psi = reshape(y(7:end), 2, 6);

    % Partial Derivatives
    A = [0, 1; -p(2)-3*p(3)*x(1)^2, -p(1)];
    dfdp = [zeros(1, 6); -x(2), -x(1), -x(1)^3, ...
        -sin(p(5)*t + p(6)), -p(4)*t*cos(p(5)*t + p(6)), -p(4)*cos(p(5)*t + p(6))];

    % State Dynamics
    xdot = [x(2); -p(1)*x(2) - p(2)*x(1) - p(3)*x(1)^2 - p(4)*sin(p(5)*t+p(6))];
    
    % Matrix Derivatives
    phidot = A*phi;
    psidot = A*psi + dfdp;
    
    % Flatten and concatenate derivatives
    f = [xdot(:); phidot(:); psidot(:)];
end